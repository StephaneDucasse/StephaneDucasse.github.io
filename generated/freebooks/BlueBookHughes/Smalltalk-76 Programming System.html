<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
<BASE HREF="http://www.ipa.net.wstub.archive.org/~dwighth/smalltalk/St76/Smalltalk76ProgrammingSystem.html">

   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Dwight Hughes">
   <meta name="GENERATOR" content="Mozilla/4.6 [en] (WinNT; I) [Netscape]">
   <title>Smalltalk-76 Programming System</title>
</head>
<body text="#000000" bgcolor="#FFF7DD" link="#0073AA" vlink="#800080" alink="#FF0000">

<center>
<hr SIZE=1 WIDTH="100%"><font color="#000099"><font size=+3>The Smalltalk-76
Programming System</font></font>
<br><font color="#000099"><font size=+3>Design and Implementation</font></font>
<p><tt>Daniel H. H. Ingalls</tt>
<br><tt>XEROX Palo Alto Research Center</tt>
<br><tt>Palo Alto, California</tt>
<p><tt>Conference Record of the</tt>
<br><tt>FIFTH ANNUAL ACM SYMPOSIUM ON</tt>
<br><tt>PRINCIPLES OF PROGRAMMING LANGUAGES</tt>
<br><tt>Tucson, Arizona</tt>
<br><tt>January 23-25, 1978</tt>
<br><tt><a href="http://info.acm.org/pubs/toc/CRnotice.html">&copy; Copyright
199x ACM, Inc., Included here by permission</a></tt></center>

<center><table BORDER=0 CELLSPACING=8 CELLPADDING=8 WIDTH="65%" >
<tr>
<td><b><font color="#000099">Abstract</font></b>
<br><i><font color="#000099">This paper describes a programming system
based on the metaphor of communicating objects. Experience with a running
system shows that this model provides flexibility, modularity and compactness.
A compiled representation for the language is presented, along with an
interpreter suitable for microcoding. The object-oriented model provides
naturally efficient addressing; a corresponding virtual memory is described
which offers dense utilization of resident space.</font></i></td>
</tr>
</table></center>
<font color="#3333FF"><font size=+2>INTRODUCTION</font></font>
<br>The purpose of the Smalltalk project is to support children of all
ages in the world of information. The challenge is to identify and harness
metaphors of sufficient simplicity and power to allow a single person to
have access to, and creative control over, information which ranges from
numbers and text through sounds and images. In our experience, the SIMULA
notion of class and instance is an outstanding metaphor for information
<i>structure</i>.
To describe
<i>processing,</i> we have found the concept of message-sending
to be correspondingly simple and general. Rather than provide this organization
as a "feature" in an existing system, we have taken these two metaphors
as the point of departure for the Smalltalk programming language. The result
is a lively interactive system which provides its own text editing, debugging,
file handling and graphics display on a personal computer.
<p>The Smalltalk language is object oriented rather than function oriented,
and this often confuses people with previous experience in computer science.
For example, to evaluate <b>&lt;some object>+4</b> means to present <b>+4</b>
as a message to the object. The fundamental difference is that the object
is in control, not <b>+</b>. If <b>&lt;some object></b> is the integer
<b>3</b>,
then the result will be the integer <b>7</b>. However, if <b>&lt;some object></b>
were the string '<b>Meta</b>', the result might be '<b>Meta4</b>'. In this
way, meaning rides with the objects of the system, and code remains an
abstract form, merely directing the flow of communication. As we shall
see, this separation is a key factor in the ability of a system to handle
complexity.
<p><font color="#3333FF"><font size=+2>THE PRINCIPLE OF MODULARITY</font></font>
<br>No part of a complex system should depend on the internal details of
any other part. The design of the Smalltalk language supports this principle
through uniform reference to <i>objects</i>, sending <i>messages</i> to
obtain results, and through organization of object descriptions and computational
methods into classes. Factoring of information structure and behavior is
provided by the implementation of <i>subclassing</i>.
<p>All references in the Smalltalk language are to objects, which may be
atomic, or may consist of several named <i>fields</i> which refer in turn
to other objects. Though the only truly atomic datum is the <i>bit</i>,
it is often appropriate for such simple objects as names and numbers to
be considered atomic. For example, in a piece of code which reads the y-coordinate
of a point in two dimensions, nowhere should there be instructions such
as: "load the second word relative to point p". Such an instruction would
not perform properly if it encountered a point represented in polar coordinates.
<p>Communication is the metaphor for processing in the Smalltalk language.
Objects are created and manipulated by sending messages. The same model
describes activities ranging from ordinary arithmetic to communicating
processes in separate machines. The response to a message is implemented
by a <i>method</i>, which reads or writes some data field, or sends further
messages to achieve the desired response. The communication metaphor supports
the principle of modularity, since any attempt to examine or alter the
state of an object is sent as a message to that object, and the sender
need never know about internal representation. For example, points represented
in polar coordinates r and theta would have a method which responds to
the message, y, by returning r*theta cos.
<div ALIGN=right><table BORDER=0 CELLSPACING=8 CELLPADDING=8 WIDTH="60%" >
<tr>
<td BGCOLOR="#FFFFFF"><font color="#333333">The examples in this paper
use a syntax which gives higher precedence to messages of fewer arguments.
Therefore theta first receives the message cos (remember, cosine is a property
of angles, not a function!), and then r receives the message * with one
argument, theta's cosine.</font></td>
</tr>
</table></div>
Every object in Smalltalk is created as an <i>instance</i> of some class.
The class holds the detailed representation of its instances, the messages
to which they can respond, and methods for computing the appropriate responses.
The only information remaining to be stored in an instance is the set of
values for its named fields. The class is the natural unit of modularity,
as it describes all the external messages understood by its instances,
as well as all the internal details about methods for computing responses
to messages and representation of data in the instances.
<p>In the Smalltalk language, a class can be declared to be a subclass
of another class, and thus inherit all the traits of that superclass. The
subclass can then add traits of its own, can override those it wishes,
and can still invoke the overridden ones from within its code. This capability
leads to a highly factored system.
<p><font color="#3333FF"><font size=+2>THE REACTIVE PRINCIPLE</font></font>
<br>The salient feature of Smalltalk is that all objects are active, ready
to perform in full capacity at any time. Nothing of this aliveness should
be lost at the interface to the human user of the system. In other words,
all components of the system must be able to present themselves to the
user in an effective way, and must moreover present a set of simple tools
for their meaningful alteration.
<p>The Smalltalk analogy to a library of useful functions is a set of well
developed superclasses from which most of the system classes are derived.
The most general of these, class <tt>Object</tt>, provides default behavior
for printing any object, or examining and altering its contents on a display
screen.
<p>In addition to a keyboard and display screen, the Smalltalk system provides
a stylus for pointing at the screen. The Smalltalk system includes a class
<tt>Window</tt>
which establishes a uniform model for interaction with these devices. From
<tt>Window</tt>,
users can define new subclasses with behavior specific to their content.
The inheritance from class <tt>Window</tt> avoids a lot of replicated code
and furnishes a uniform model for reactive control over new objects added
by the user.
<table CELLSPACING=8 >
<tr>
<td><img SRC="st76figure1.gif" height=514 width=400></td>
</tr>

<tr>
<td>
<center><b>Figure 1.</b> <b>A typical Smalltalk display</b></center>
</td>
</tr>
</table>
Figure 1 shows a typical display screen from a Smalltalk system. Each of
the rectangular areas is an instance of class Window which provides a basic
protocol for user interaction:
<ul>
<li>
&nbsp;if the stylus is depressed within the window, the content is redisplayed,
thus showing it "in front of" the other windows;</li>

<li>
&nbsp;once active, the window becomes the recipient of all user actions,
such as depressing the stylus, typing on the keyboard, or entering sensitive
areas around the window;</li>

<li>
&nbsp;if the stylus is depressed outside the window, control is given up
so that another window may be awakened.</li>
</ul>
The class <tt>Window</tt> also provides a basic protocol for handling such
actions as moving itself, changing its size, printing its contents, and
terminating its appearance on the screen.
<div ALIGN=right><table BORDER=0 CELLSPACING=8 CELLPADDING=8 WIDTH="60%" >
<tr>
<td ALIGN=LEFT VALIGN=TOP BGCOLOR="#FFFFFF"><font color="#333333">The reader
may find himself evaluating the user interface presented in the figures.
This misses the point, which is the aptness of communicating objects in
describing the situation. Many other approaches to display handling are
used with Smalltalk, and they are not the subject of this paper.</font></td>
</tr>
</table></div>

<table CELLSPACING=8 >
<tr>
<td><img SRC="st76figure2.gif" height=505 width=400></td>
</tr>

<tr>
<td>
<center><b>Figure 2. Editing text</b></center>
</td>
</tr>
</table>
Each of the windows shown in the figure belongs to some subclass of
<tt>Window</tt>;
the subclass handles the specific content. In figure 2, for example, the
user has awakened a window for editing the text of a class. Specific to
this content is the ability to select text with the stylus, scroll the
text up and down by entering the scroll bar at the window's left, and send
specific editing messages by entering the menu at its right. The class
has thus provided a simulation of itself as structured text (which is needed
for printing anyway). This text in turn furnishes a text editor to display
the text and allow it to be manipulated. Finally, the window provides a
spatial channel for the flow of information in both directions between
the user and the subject of investigation. As shown in figure 2, the user
has just drawn the stylus through the text of the message <b>show</b>,
and the editor has responded by highlighting the text and noting the selection
internally.
<p>In figure 3, the currently active window supports freehand drawing.
It provides a large menu from which to choose brush shape and paint tone
to be applied when the stylus is depressed. Another window interfaces to
one of the character fonts, allowing the user to design new fonts at will.
Yet another displays the time of day. Each of the windows brings its own
semantics to the uniform "syntax" of stylus motion and keyboard action
available to the investigator. In this way, the underlying metaphor of
communicating objects can be seen to operate all the way up to the level
which corresponds to a conventional operating system.
<table CELLSPACING=8 >
<tr>
<td>
<center><img SRC="st76figure3.gif" height=505 width=400></center>
</td>
</tr>

<tr>
<td>
<center><b>Figure 3. Painting a picture</b></center>
</td>
</tr>
</table>
<font color="#3333FF"><font size=+2>EXAMPLE OF A SMALLTALK CLASS: Rectangle</font></font>
<br>As we have seen above, most programming in Smalltalk is done using
a structured editor. Rather than go into the details of this process, we
show here an excerpt from class <tt>Rectangle</tt>, show how it supports
the <tt>Window</tt> example above, and describe in detail the operation
of one of its messages.
<p>A Smalltalk class is defined by giving it a name, and naming the fields
of its instances. Following this is an optionally categorized list of the
messages to which the class responds. Each message consists of a pattern
followed by Smalltalk code within brackets.
<dl>
<dd>
<b><font size=+1>Class new title: 'Rectangle';</font></b></dd>

<dd>
<b><font size=+1>&nbsp;&nbsp;&nbsp; fields: 'origin corner'.</font></b></dd>

<dd>
<b><font size=+1>&nbsp;</font></b></dd>

<dd>
<b><font color="#000000"><font size=+1>Access to fields</font></font></b></dd>

<dd>
<b>origin&nbsp;&nbsp; </b>[<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>origin]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"&nbsp;<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>
means return"</dd>

<dd>
<b>corner&nbsp; </b>[<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>corner]</dd>

<dd>
<b>origin: origin corner: corner</b></dd>

<dl>
<dd>
&nbsp;&nbsp;&nbsp; "no code; just store into the instance"</dd>
</dl>

<dd>
<font size=+1>&nbsp;</font></dd>

<dd>
<b><font color="#000000"><font size=+1>Testing</font></font></b></dd>

<dd>
<b>contains: pt</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "return true
if pt is inside me"</dd>

<dl>
<dd>
[<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>origin&nbsp;<img SRC="less-than-or-equal.gif" height=13 width=10 align=ABSCENTER>
pt and: pt&nbsp;<img SRC="less-than-or-equal.gif" height=13 width=10 align=ABSCENTER>
corner]</dd>
</dl>

<dd>
<b>empty </b>[<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>corner&nbsp;<img SRC="greater-than-or-equal.gif" height=13 width=10 align=ABSCENTER>
origin]</dd>

<dd>
<font size=+1>&nbsp;</font></dd>

<dd>
<b><font size=+1>Combination</font></b></dd>

<dd>
<b>inset: delta</b></dd>

<dl>
<dd>
[<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>origin
+ delta rect: corner - delta]</dd>
</dl>

<dd>
<b>intersect: r</b></dd>

<dl>
<dd>
[<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>(origin
max: r origin) rect: (corner min: r corner)]</dd>
</dl>

<dd>
<font size=+1>&nbsp;</font></dd>

<dd>
<b><font size=+1>Image</font></b></dd>

<dd>
<b>clear: color&nbsp;&nbsp; </b>[primitive]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"display operation"</dd>

<dd>
<b>outline: width</b></dd>

<dl>
<dd>
[(self inset: (<img SRC="unary-negation.gif" height=9 width=9 align=TEXTTOP>1<img SRC="make-point.gif" height=16 width=12 align=ABSCENTER><img SRC="unary-negation.gif" height=9 width=9 align=TEXTTOP>1)
* width) clear: black.</dd>

<dd>
self clear: white]</dd>
</dl>

<dd>
<b>moveto: pt</b></dd>

<dl>
<dd>
[corner&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
corner - origin + pt.</dd>

<dd>
origin&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
pt]</dd>
</dl>
</dl>
Rectangles have two fields: <b>origin</b> is the lower left corner, and
<b>corner</b>
is the upper right corner. Because both <b>origin</b> and
<b>corner</b>
are <tt>Points</tt>, <tt>Rectangle</tt> builds on a data domain which is
already graphically interesting.
<dl>
<dd>
<b><font size=+1>Class new title: 'Point';</font></b></dd>

<dd>
<font size=+1><b>&nbsp;&nbsp;&nbsp; fields: 'x y'.</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"</font>Cartesian coordinates"</dd>

<dd>
&nbsp;</dd>

<dd>
<b><font size=+1>Access to fields</font></b></dd>

<dd>
<b>x</b>&nbsp;&nbsp; [<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>x]</dd>

<dd>
<b>y&nbsp;&nbsp;</b> [<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>y]</dd>

<dd>
<b>x: x y: y</b></dd>

<dd>
<b>&nbsp;</b></dd>

<dd>
<b><font size=+1>Testing</font></b></dd>

<dd>
<img SRC="less-than-or-equal.gif" height=13 width=10 align=TEXTTOP> <b>pt</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"return true if I am below/left of pt"</dd>

<dl>
<dd>
[<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>x&nbsp;<img SRC="less-than-or-equal.gif" height=13 width=10 align=ABSCENTER>
pt x and: y&nbsp;<img SRC="less-than-or-equal.gif" height=13 width=10 align=ABSCENTER>
pt y]</dd>
</dl>

<dd>
&nbsp;</dd>

<dd>
<b><font size=+1>Combination</font></b></dd>

<dd>
<b>rect: c</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
"make up a new rectangle"</dd>

<dl>
<dd>
[<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>Rectangle
new origin: self corner: c]</dd>
</dl>

<dd>
&nbsp;</dd>

<dd>
<b><font size=+1>Point arithmetic</font></b></dd>

<dd>
<b>+</b>&nbsp;&nbsp; <b>pt</b>&nbsp;&nbsp; [<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>Point
new x: x + pt x y: y + pt y]</dd>

<dd>
<b>-</b>&nbsp;&nbsp; <b>pt</b>&nbsp;&nbsp; [<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>Point
new x: x - pt x y: y - pt y]</dd>
</dl>
The scheduling of windows shown in figures 1-3 is implemented in <tt>Window</tt>'s
response to the message <b>startup</b> (visible in figure 1). The chief
element in the code is the expression
<dl>
<dd>
<b>frame contains: stylus loc</b></dd>
</dl>
which checks whether the stylus location (a <tt>Point</tt>) is within the
frame (a <tt>Rectangle</tt>) of the current <tt>Window</tt>. The code for
<tt>Rectangle
</tt><b>contains:
</b>builds,
in the procedural domain, on the meaning of&nbsp;<img SRC="less-than-or-equal.gif" height=13 width=10 align=ABSCENTER>
for <tt>Points</tt>. The first test determines that <b>origin</b> is below
and to the left of the <tt>Point </tt><b>pt</b>, and the second test determines
that <b>pt</b> is below and to the left of <b>corner</b>. The reader will
want to know here that arithmetic messages (<b><font size=+1>+, -,</font></b>
etc.) get sent before keyword messages (the identifiers ending in colon).
Therefore, after the two&nbsp;<img SRC="less-than-or-equal.gif" height=13 width=10 align=ABSCENTER>
tests have been made, the conjunction of the two results defines the case
that the rectangle contains the <tt>Point </tt><b>pt</b>.
<div ALIGN=right><table BORDER=0 CELLSPACING=8 CELLPADDING=8 COLS=1 WIDTH="60%" >
<tr>
<td BGCOLOR="#FFFFFF"><font color="#333333">Smalltalk treats all objects
which are not false as true. This is effected rather easily in class <tt>Object</tt>
by messages of the form:&nbsp;</font>
<dl>
<dd>
<b><font color="#000000">and: x [self = false&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>false]&nbsp;<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>x]</font></b><font color="#000000">,&nbsp;</font></dd>
</dl>
<font color="#333333">which are inherited by all other classes. The implication
arrow is a primitive operation which compiles into a branch conditional
on the distinguished object, <b>false</b>.&nbsp;</font></td>
</tr>
</table></div>
The other messages to <tt>Rectangle</tt> are presented so that interested
readers can pursue the message <b>outline: w</b>, which causes an outline
of width <b>w</b> to appear around the rectangle on the screen. This message
is used by class <tt>Window</tt> to clear and outline its frame.
<div ALIGN=right><table BORDER=0 CELLSPACING=8 CELLPADDING=8 WIDTH="60%" >
<tr>
<td ALIGN=LEFT VALIGN=TOP BGCOLOR="#FFFFFF"><font color="#333333">These
readers will want to know that if several keyword messages appear at a
given level, they combine to provide a message with multiple arguments.
For example, class
<tt>Number</tt> provides a message&nbsp;</font>
<dl>
<dd>
<img SRC="make-point.gif" height=16 width=12 align=TEXTTOP><b><font color="#000000">
arg&nbsp; [<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>Point
new x: self y: arg]</font></b></dd>
</dl>
<font color="#333333">for creating <tt>Points</tt> simply. This code sends
the compound message <b>x:y:</b> to the new <tt>Point</tt> with the two
arguments, <b>self</b> and
<b>arg</b>.</font></td>
</tr>
</table></div>
<b><font color="#000099"><font size=+1>The Benefits of the Message Discipline</font></font></b>
<br>Adding a new class of data to a programming system is soon followed
by the need to print objects of that class. In many extensible languages,
this can be a difficult task at a time when things should be easy. One
is faced with having to edit the system print routine which (a) is difficult
to understand because it is full of details about the rest of the system,
(b) was written by someone else and may even be in another language, and
(c) will blow the system to bits if you make one false move. Fear of this
often leads to writing a separate print routine with a different name which
then must be remembered. In our object-oriented system, on the other hand,
printing is always effected by sending the message <b>printon:</b> <b>s</b>
(where <b>s</b> is a character stream) to the object in question. Therefore
the only place where code is needed is right in the new class description.
If the new code should fail, there is no problem; the existing system is
unmodified, and can continue to provide support.
<p>The code for moving a <tt>Rectangle</tt> (<b>moveto:</b>) could be more
efficient if <b>corner</b> were relative to <b>origin</b>, so that it did
not need to be relocated. This could be accomplished by changing names
from
<dl>
<dd>
<b>fields: 'origin corner'</b></dd>
</dl>
to
<dl>
<dd>
<b>fields: 'origin extent'</b>,</dd>
</dl>
and updating the code from
<dl>
<dd>
<b>moveto: pt&nbsp;&nbsp; </b>[corner&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
corner - origin + pt.</dd>

<dl>
<dl>
<dd>
origin&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
pt]</dd>
</dl>
</dl>
</dl>
to
<dl>
<dd>
<b>moveto: pt&nbsp;&nbsp; </b>[origin&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
pt]</dd>
</dl>
In a conventional organization, all the code in the system will have to
be recompiled because it used to count on finding the corner coordinates
in the second field. In fact most systems would require <i>rewriting</i>
because access to the corner (which used to be a simple load or store)
becomes a computation:
<dl>
<dd>
<b>corner&nbsp;&nbsp;&nbsp; </b>[<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>origin
+ extent]</dd>

<dd>
<b>corner:&nbsp;&nbsp; </b>[extent&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
pt - origin]</dd>
</dl>
The class organization and message discipline ensure that if the original
message protocol is supported, then all code outside the class will continue
to work without even recompiling. Moreover, the only changes required will
all be within the class whose representation is being changed.
<p>Modularity is not just an issue of "cleanliness." If N parts depend
on the insides of each other, then <i>some</i> aspect of the system will
be proportional to N-squared. Such interdependencies will interfere with
the system's ability to handle complexity. The phenomenon may manifest
itself at any level: difficulty of design, language overgrown with features,
long time required to make a change or difficulty of debugging. Messages
enforce an organization which minimizes interdependencies.
<p>Another benefit of leaving message interpretation up to the target objects
is type independence of code. In the <tt>Rectangle</tt> example, the code
will work fine if the coordinates are <tt>Integer</tt> or <tt>FloatingPoint</tt>,
or even some newly-defined numerical type. This allows for much sharing
of code, and the ability to have one object masquerade as another.
<p><b><font color="#000099"><font size=+1>The Power of Subclasses</font></font></b>
<br>The utility of type-independent code is exploited by the subclass organization
in Smalltalk. For example, the superclass <tt>Number</tt> implements the
messages
<dl>
<dd>
&nbsp;<img SRC="less-than-or-equal.gif" height=13 width=10><b><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img SRC="greater-than-or-equal.gif" height=13 width=10>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img SRC="not-equal.gif" height=14 width=11>&nbsp;&nbsp;&nbsp;
max:&nbsp;&nbsp; min:</font></b></dd>
</dl>
in terms of the basic comparisons, <b><font size=+1>&lt;</font></b>, <b><font size=+1>=</font></b>,
and <b><font size=+1>></font></b>. Consequently, after defining only the
basic comparisons, any new subclass of <tt>Number</tt> can respond to the
full numerical protocol. Other messages in the superclass
<tt>Number</tt>,
such as&nbsp;<img SRC="make-point.gif" height=16 width=12 align=ABSCENTER>
(which creates a <tt>Point</tt>) and <b>to:by:</b> (which creates an interval),
similarly allow coordinates of <tt>Points</tt>, and limits of for-loop
ranges to be <tt>FloatingPoint</tt>, <tt>Fraction</tt>, or any other kind
of <tt>Number</tt>.
<p>The factoring provided by subclassing leads to cleanliness and compactness.
It can also increase efficiency through multiplied use of high-speed system
code. For instance, we provide microcode support for reading and writing
the next item in a <tt>Stream</tt>. Now by making class <tt>DiskFile</tt>
a subclass of <tt>Stream</tt>. <tt>DiskFile</tt> inherits this very efficient
code for its most common operations. The superclass <tt>Stream</tt> sends
itself the message <b>pastend</b> when it reaches the end of its character
buffer, and this gives the subclass <tt>DiskFile</tt> a chance to read
a new record off the disk by overriding the meaning of <b>pastend</b>.
<p>Besides allowing subclasses to override messages in their superclasses,
Smalltalk provides for access to the overridden messages. In figure 2,
the selected text defines the message <b>show</b> to <tt>DocWindow</tt>,
<dl>
<dd>
<b>show&nbsp;&nbsp; </b>[super show.&nbsp; self showDoc]</dd>
</dl>
which overrides <tt>Window</tt>'s definition. The token, <b>super</b>,
indicates that the following message should be looked up beginning with
the class above. In this case it allows <tt>DocWindow</tt> to invoke <tt>Window</tt>'s
<b>show</b>
code to put a frame around the window before telling the document to display
its text.
<p>Further properties of Smalltalk subclassing, including multiple inheritance
of traits, are beyond the scope of this paper.
<p><font color="#3333FF"><font size=+2>IMPLEMENTATION</font></font>
<br>The challenge of implementing the Smalltalk language is to provide
acceptable performance without compromising the simplicity of the underlying
metaphors. Beyond the laudable goals of modularity and factoring, four
pragmatic issues affect the performance of the Smalltalk system: storage
management, compact object code, message handling, and a decent virtual
memory.
<p><b><font color="#000099"><font size=+1>Storage Management</font></font></b>
<br>Requiring the programmer to manage the allocation and deallocation
of objects is out of the question in a true high-level language. It is
a sure source of errors and it clutters the code with irrelevant pragmatics.
Instead, the Smalltalk kernel maintains reference counts for all objects,
and frees them to be reused when the count goes to zero. We chose reference
counting over garbage collection because the computational overhead is
more uniform in real-time, and the behavior with little free storage is
better. The dominant flow of data in a programming system is usually small
integers, either representing characters or results of simple arithmetic
and indexing. The Smalltalk system reclaims small integers without reference
counting (they are special object references); this one wild-card (present
in some LISP systems) reduces the overhead to a reasonable level.
<p>The reclamation of cyclic structures cannot be handled by reference
counting, but we have not found this to be a problem. The class architecture
makes it especially convenient to manage objects which are going to participate
in cyclic structures. For each cyclic link field, an appropriate <b>unlink</b>
message can be defined which propagates through the structure breaking
the cycle. It is true that this discipline corresponds to explicit storage
management, but it is well localized, and hence presents little problem.
<p><b><font color="#000099"><font size=+1>Compact Object Code</font></font></b>
<br>Dear to our hearts is the ability to run Smalltalk on personal computers.
In this arena, compactness of the system is crucial and worth sacrificing
some raw speed to achieve. Moreover, our experience with virtual memory
systems is that overall performance actually improves with compactness
owing to reduced swapping of the working set. To this end, the Smalltalk
system translates source code into compact syllables corresponding to the
elements of the language.
<table BORDER=0 CELLSPACING=8 >
<tr>
<td>
<center><img SRC="st76figure4.gif" height=624 width=635></center>
</td>
</tr>

<tr>
<td>
<center><b>Figure 4 - Smalltalk Structures</b></center>
</td>
</tr>
</table>
The top of figure 4 illustrates the static structure in Smalltalk-76 corresponding
to <tt>Rectangle </tt><b>contains:</b>. One of the fields of the class
points to an object called a <tt>MessageDictionary</tt>. This is a hash
table whose keys are the message names (<tt>UniqueStrings</tt>) and whose
value parts include the corresponding compiled method and also the source
code. The compiler translates the source code into syllables arranged in
postfix order using what the class knows about instance fields and other
variable locations. Including some setup information discussed below, the
code body for computing <b>contains:</b> occupies 14 code syllables or,
in our system, seven 16-bit words.
<p>The choice of encoding is made by translating every common item into
a single syllable, and then providing escapes for cases where this is impossible.
The codes fall into the following basic categories:
<br>&nbsp;
<table BORDER=0 WIDTH="60%" >
<tr>
<td WIDTH="6%"></td>

<td ALIGN=RIGHT>1</td>

<td WIDTH="4%"></td>

<td>Load relative to receiver (<b>self</b>)</td>
</tr>

<tr>
<td></td>

<td ALIGN=RIGHT>2</td>

<td></td>

<td>Load relative to temp frame</td>
</tr>

<tr>
<td></td>

<td ALIGN=RIGHT>3</td>

<td></td>

<td>Load relative to literals</td>
</tr>

<tr>
<td></td>

<td ALIGN=RIGHT>4</td>

<td></td>

<td>Load indirect literals</td>
</tr>

<tr>
<td></td>

<td ALIGN=RIGHT>5</td>

<td></td>

<td>Load relative to context</td>
</tr>

<tr>
<td></td>

<td ALIGN=RIGHT>6</td>

<td></td>

<td>Load constant</td>
</tr>

<tr>
<td></td>

<td></td>

<td></td>

<td>&nbsp;</td>
</tr>

<tr>
<td></td>

<td ALIGN=RIGHT>7</td>

<td></td>

<td>Send literal message</td>
</tr>

<tr>
<td></td>

<td ALIGN=RIGHT>8</td>

<td></td>

<td>Send special message</td>
</tr>

<tr>
<td></td>

<td></td>

<td></td>

<td>&nbsp;</td>
</tr>

<tr>
<td></td>

<td ALIGN=RIGHT>9</td>

<td></td>

<td>Short jumps</td>
</tr>

<tr>
<td></td>

<td ALIGN=RIGHT>10</td>

<td></td>

<td>Long jumps</td>
</tr>

<tr>
<td></td>

<td ALIGN=RIGHT>11</td>

<td></td>

<td>Control ops</td>
</tr>

<tr>
<td></td>

<td></td>

<td></td>

<td>&nbsp;</td>
</tr>

<tr>
<td></td>

<td ALIGN=RIGHT>12</td>

<td></td>

<td>Escapes</td>
</tr>
</table>
&nbsp;
<br>The loads pick up an object reference and push it onto an evaluation
stack, and the message codes either cause a primitive operation or invoke
another context, depending on the actual message and the receiver on top
of the stack. The jumps come in two flavors, unconditional and conditional,
the latter taking place only if the top of stack is false, but popping
the stack in any event. The long jumps are followed by an extension syllable.
The control ops include returning to caller, pop stack, and store, which
is followed by a load-like syllable describing the destination field. The
escapes work like the long jumps, extending the loads and sends by a full
syllable of offset. An area is set aside in the method for literals (object
references which do not fit into a syllable), and these serve when necessary
as an escape to refer to unusual constants, external references or message
tokens. Our example (which does not use any literals) would be encoded
as
<br>&nbsp;
<table BORDER=0 WIDTH="60%" >
<tr>
<td WIDTH="6%"></td>

<td ALIGN=LEFT WIDTH="8%">origin</td>

<td WIDTH="4%"></td>

<td>load receiver.0</td>
</tr>

<tr>
<td></td>

<td ALIGN=LEFT>corner</td>

<td></td>

<td>load receiver.1</td>
</tr>

<tr>
<td></td>

<td ALIGN=LEFT>pt</td>

<td></td>

<td>load temp.0</td>
</tr>

<tr>
<td></td>

<td ALIGN=LEFT><img SRC="less-than-or-equal.gif" height=13 width=10 align=TEXTTOP></td>

<td></td>

<td>send special message.7</td>
</tr>

<tr>
<td></td>

<td ALIGN=LEFT>and:&nbsp;</td>

<td></td>

<td>send special message.12</td>
</tr>

<tr>
<td></td>

<td ALIGN=LEFT><img SRC="return-arrow.gif" height=14 width=11 align=TEXTTOP></td>

<td></td>

<td>do control.3</td>
</tr>
</table>
&nbsp;
<br>The encoded methods typically occupy one quarter the space of the original
source code. In implementations with no virtual memory, therefore, it would
be important to reconstruct the source from the code syllables.
<p><b><font color="#000099"><font size=+1>Message Handling</font></font></b>
<br>Execution of the code syllables is relatively simple, and the lower
half of figure 4 illustrates the dynamic environment. When a <tt>Rectangle</tt>
receives the message <b>contains:</b>, an instance of class <tt>Context</tt>
is allocated to serve much the function of a conventional call frame. Its
<b>sender</b>
field points to the context of its caller, to which the final value of
its computation will be passed with the return (<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>)
operator. The
<b>self</b> field points to the object who is receiving this
message; in our example it is a <tt>Rectangle</tt>. The <b>mclass </b>field
in this example is simply the class <tt>Rectangle</tt>, but in the case
of messages which are inherited from superclasses, it indicates the class
from which the message was inherited (this is needed to provide the <i>super</i>
access described earlier). <b>Method</b> points to the object code for
the method being executed, and <b>pc</b> is a syllable offset into it indicating
the current progress of execution. <b>Tempframe</b> points to a <tt>Vector</tt>
of temporary storage for the computation. Its access is partitioned into
three areas: arguments passed from its caller, other temporaries required
for the computation (none in our example), and the stack area used in evaluating
the syllables. <b>Stackptr</b> is the offset indicating the current top
of stack.
<p>The Smalltalk system gets a great deal of mileage out of the fact that
<tt>Contexts</tt>
are objects of full capability, just like all the other parts of the system.
For debugging, the <tt>Context</tt> is in a position to reveal the location
of the pc, the contents of the stack, the values of temporary variables
and the current state of the receiver. For analysis purposes, the operation
of the interpreter is simulated in Smalltalk by a loop which sends the
message <b>step</b> to the current context:
<dl>
<dd>
<b>repeat<img SRC="open-colon.gif" height=16 width=8 align=TEXTTOP> [current&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
current step].</b></dd>
</dl>
An outline of this simulation appears in an <a href="#st76_appendix">appendix</a>
to this paper.
<p>Most of the task of interpretation is implicit in the syllable descriptions
above. The one complex operation worthy of further clarification is how
a new context gets set up to send a message to a new receiver. Our example
of figure 4 will serve us again: <b>corner</b> has been put on the stack,
and <b>pt</b> above it is the top item in the stack, and the next syllable
pointed to by <b>pc</b> indicates that the message&nbsp;<img SRC="less-than-or-equal.gif" height=13 width=10 align=ABSCENTER>
is to be sent. The very first thing that happens (since this is a common
arithmetic operation) is that <b>pt</b> is checked to see if it is an <tt>Integer</tt>
allowing a fast primitive operation; but it is not. The more general process
then begins of hashing the token&nbsp;<img SRC="less-than-or-equal.gif" height=13 width=10 align=ABSCENTER>
into the <tt>MessageDictionary</tt> of <b>pt</b>'s class, <tt>Point</tt>.
A match is indeed found, and the resulting code object can be installed
in the new context along with<b> pt </b>(popped off the stack) in the
<b>self</b>
field, class <tt>Point</tt> in the <b>mclass</b> field, and the previous
context in the <b>sender</b> field.
<p>The setup parameters in the beginning of the method are computed at
compile time, and serve to initialize the new environment. They tell how
much space is needed for the <b>tempframe</b> and how many arguments are
expected (one here). After the arguments have been moved from the previous
stack to the beginning of the <b>tempframe</b>, the setup supplies initial
values of <b>stackptr</b> and <b>pc</b>, and the new context is ready to
run. It will eventually terminate by encountering a <i>return</i> syllable.
Then the value (<tt>true</tt> or <tt>false</tt>) on the top of the stack
will get pushed back onto the sender's stack, and the computation of <tt>Rectangle
</tt><b>contains:
</b>will
resume where it left off.
<p><b><font color="#000099"><font size=+1>Efficient Message Handling</font></font></b>
<br>It should be obvious that to carry the message sending metaphor down
into integer arithmetic will result in a slow system on any non message
oriented computer. The implementor must cheat, but not get caught. In other
words, the user of the system should not perceive any non-uniformity.
<p>To achieve acceptable performance, it is important that the microcode
interpreter <i>not</i> send messages to <tt>Contexts</tt>. It performs
all the same steps. but in the fastest way possible.
<p>The Smalltalk system achieves its speed by the assignment of special
code syllables to the most frequently executed operations. For instance,
the message <b>+</b> is assigned a special code, and the (microcode) interpreter
responds to that code by immediately checking whether both receiver and
argument are of class Integer. If so, it does the addition in-line and
proceeds immediately without even looking up the symbol plus, let alone
creating a new context. If the check fails, then control passes to the
normal message sending code, thus insuring the appearance of uniformity.
<p><b><font color="#000099"><font size=+1>Virtual Memory</font></font></b>
<br>One of the most satisfying aspects of a system built of objects is
the naturally efficient use of address space. Since a Smalltalk reference
can only point to an object as a whole, the Smalltalk system can indicate
2<sup>16</sup> distinct objects using 16-bit object references. With a
mean object size of 20 words, the system can address over a million words,
and this size is a nice match to the size of common personal computer disk
drives. In implementing this virtual memory, we decided to swap single
objects, thus achieving maximum utilization of resident storage at the
possible expense of slower establishment of workingset. Without a few tricks
this scheme could never work.
<p>First, a poor man's Huffman code associates the class of an object with
its object reference, thus avoiding a 1-word class-pointer overhead on
every object. The address space is given to classes for their instances
in <i>zones</i> of 128 with the same high-order bits. It is therefore possible
to index a table with the high order bits of any object reference and discover
the class of that object.
<p>Second, variable length classes have many such zones, one for each of
the common small lengths. In this way the overhead of a length word is
avoided on the small sizes. For larger sizes, the zones cover octave ranges
(i.e., 9-16, 17-32, and so on) and an extra word specifies the exact length.
<p>Third, these zones of address space are mapped into contiguous locations
on the disk. Since all the objects are instances of the same class, they
have the same size; hence the page and offset on the disk can be computed
from the low order bits of the object reference. In this way non-resident
objects can be located on the disk to be brought into core. For the octave
sizes, a little wasted space on the disk is traded for the ability to compute
the disk offset location.
<p>Fourth, the zoning provides a solution to the problem of making free
space without thrashing the disk. Here is the problem: there are 1000 objects
in core, roughly 20 words each, and we suddenly need 500 words of space;
if we have to write out 25 objects (assuming we can even decide which ones),
how do we keep from doing 25 disk seeks to do it? Our solution is to purge
core by zone, thus writing many objects together on a page, and sweeping
over the disk in order of pages. Moreover, a single bit on each object
meaning "I've been touched since my zone was last purged" provides a nice
aging criterion for selecting objects to be purged.
<p><font color="#3333FF"><font size=+2>CONCLUSION</font></font>
<br>We have known for some time that the uniform model of communicating
objects leads to a naturally integrated programming system. A very gratifying
aspect to our work is the demonstration that this approach can also result
in an efficient implementation. The Smalltalk system has supported large
applications for simulation, information retrieval, text editing, musical
composition and animation without encountering significant barriers to
complexity, and this is our strongest indication of the worth of the language.
Beyond this I must add that programming in Smalltalk is fun. On the one
hand, the act of assembling expressions into statements and then into methods
is not very different from conventional programming. On the other hand,
the experience is totally different, for the objects which populate and
traverse the code are active entities, and writing expressions feels like
organizing trained animals rather than pushing boxes around.
<p><b><font color="#000099"><font size=+1>Acknowledgement</font></font></b>
<br>Many people have contributed to the Smalltalk system. Alan Kay has
been expounding the basic principles for about a decade now, and the rest
has unfolded through the love and energy of the whole Learning Research
Group. Smalltalk-76 was implemented by the author with the assistance of
Ted Kaehler, Diana Merry, and Dave Robson. Several other people at PARC
have contributed significantly, most notably Larry Tesler and Peter Deutsch.&nbsp;
<hr ALIGN=LEFT SIZE=1 WIDTH="100%">
<dl>
<dd>
<b><font color="#000099"><font size=+1>References&nbsp;
<hr ALIGN=LEFT SIZE=1 WIDTH="60%"></font></font></b>Kay, A. <i>FLEX, a
flexible extensible language</i></dd>

<dl>
<dd>
M.S. thesis, Univ of Utah, May, 1968 (Univ. Microfilms).</dd>
</dl>

<dd>
Kay, A. <i>The Reactive Engine</i></dd>

<dl>
<dd>
PhD. thesis, Univ of Utah, Sept., 1969 (Univ. Microfilms).</dd>
</dl>

<dd>
Learning Research Group. <i>Personal Dynamic Media</i>.</dd>

<dl>
<dd>
SSL76-1, Xerox PARC, Palo Alto, Calif., April 1976.</dd>
</dl>

<dd>
Birtwistle, G., Dahl, 0.-J., Myhrhaug. B., Nygaard, K.</dd>

<dl>
<dd>
<i>Simula Begin</i>. Auerbach, Philadelphia, Pa., 1973.</dd>
</dl>

<dd>
Fisher, D. A. <i>Control Structures for Programming Languages</i>.</dd>

<dl>
<dd>
PhD. thesis, Carnegie-Mellon Univ. Pittsburg, 1970</dd>
</dl>

<dd>
Liskov, B. and Zilles, S. <i>Programming with Abstract Data Types</i>.</dd>

<dl>
<dd>
SIGPLAN Notices, April 1974, 50-59.</dd>
</dl>

<dd>
Liskov, B. <i>An Introduction to CLU</i>.</dd>

<dl>
<dd>
CSG Memo 136, MIT LCS, Febuary 1976.</dd>
</dl>

<dd>
Greif, I. and Hewitt, C. <i>Actor Semantics of PLANNER-73</i>.</dd>

<dl>
<dd>
ACM SIGPLAN-SIGACT Conf., Palo Alto, Calif., Jan 1975.</dd>
</dl>

<dd>
Steiger, R. <i>Actor Machine Architecture</i>.</dd>

<dl>
<dd>
M.S. thesis, MIT Dept. EECS, June 1974.</dd>
</dl>

<dd>
Deutsch, L. P. <i>A LISP Machine with Very Compact Programs</i>.</dd>

<dl>
<dd>
IJCAI, Stanford, Calif., August 1973.</dd>
</dl>

<dd>
Deutsch, L. P. and Bobrow, D. <i>An Efficient Incremental Automatic Garbage
Collector</i>.</dd>

<dl>
<dd>
CACM September 1976.</dd>
</dl>

<dd>

<hr ALIGN=LEFT SIZE=1 WIDTH="60%"></dd>
</dl>

<hr ALIGN=LEFT SIZE=1 WIDTH="100%"><a NAME="st76_appendix"></a><u><font color="#3333FF"><font size=+2>APPENDIX:&nbsp;&nbsp;
A Smalltalk Simulation of the Interpreter</font></font></u>
<p><b><font size=+1>Class new title: 'Context';</font></b>
<br><b><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp; fields: 'sender method pc
tempframe stackptr mclass receiver';</font></b>
<br><b><font size=+1>&nbsp;&nbsp;&nbsp;&nbsp; asFollows!</font></b>
<br>&nbsp;
<br><i>Contexts carry the dynamic state of Smalltalk processes. They are
accessed in efficient ways by the microcode interpreter. At the same time,
they are instances of a perfectly normal Smalltalk class. In this way,
the full generality of Smalltalk can be applied to examining and tracing
the progress of Smalltalk execution.</i>
<br>&nbsp;
<br><i>The code below differs from the actual code in Smalltalk-76 in that
it corresponds to the slightly simplified categories of the text, and has
not been carefully checked for off-by-1 errors.</i>
<br>&nbsp;
<br><i>Beyond the specifics in the text, the interested reader will want
to know:</i>
<dl>
<ul>
<li>
<i>"&nbsp;<img SRC="subscript-bullet.gif" height=9 width=8 align=ABSCENTER>"
is the subscript message, as in:&nbsp; tempframe<img SRC="subscript-bullet.gif" height=9 width=7 align=ABSCENTER>lobits</i></li>

<li>
<i>except for assignment, "&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>"
is treated as an agglutinating message part, as in:&nbsp; t<img SRC="subscript-bullet.gif" height=9 width=8 align=ABSCENTER>i&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
self pop</i></li>

<li>
<i>the&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
symbol indicates conditional execution; if the preceding value is true,
then the following body of code is executed, and control exits the outer
(!) brackets. This "if-only" form serves to build dispatch tables as in
the message "next" below</i></li>

<li>
<i>the default value returned from any message is "self", the receiver
of the message. Other values may be returned with the "&nbsp;<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>"
symbol.</i></li>
</ul>
</dl>
<i>The messages "instfield: n" and "instfield: n&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
val", which are used below to read and write the n-th field of an instance,
clearly violate the principle of modularity. This reflects that the buck
stops here, and these primitive messages appear nowhere else in the system.</i>
<br>&nbsp;
<br><b><font color="#000000"><font size=+1>Access to Fields</font></font></b>
<br><b>sender: sender method: method pc: pc tempframe: tempframe stackptr:
stackptr</b>
<br><b>&nbsp;&nbsp;&nbsp; mclass: mclass receiver: receiver</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<i>"initializes all fields"</i>
<dl>
<dt>
<b><font size=+1>Simulation of the Interpreter</font></b></dt>

<dt>
<b>step | byte lobits</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<i>"dispatch on next code syllable"</i></dt>

<dl>
<dt>
[byte&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
self nextbyte.</dt>

<dt>
lobits&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
byte | 16.</dt>

<dt>
byte/16 =1&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[self push: receiver instfield: lobits];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"load from instance"</i></dt>

<dl>
<dt>
=2&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[self push: tempframe<img SRC="subscript-bullet.gif" height=9 width=8 align=ABSCENTER>lobits];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"load from temps (and args)"</i></dt>

<dt>
=3&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[self push: (method literals: lobits)];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"load from literals"</i></dt>

<dt>
=4&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[self push: (method literals: lobits) value];&nbsp;&nbsp;&nbsp;&nbsp; <i>"load
indirectly from literals"</i></dt>

<dt>
=5&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[self push: self instfield: lobits];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"load from this Context"</i></dt>

<dt>
=6&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[self push:&nbsp;<img SRC="literal-array.gif" height=15 width=22 align=ABSCENTER>(<img SRC="unary-negation.gif" height=9 width=9 align=TEXTTOP>1
0 1 2 10 true false nil)<img SRC="subscript-bullet.gif" height=9 width=8 align=ABSCENTER>lobits];
<i>"frequent constants"</i></dt>

<dt>
=7&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>self send:
(method literal: lobits)];</dt>

<dt>
=8&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>self send:
(SpecialMessages<img SRC="subscript-bullet.gif" height=9 width=8 align=ABSCENTER>lobits)];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"frequent messages"</i></dt>

<dt>
=9&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[lobits &lt; 8&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[pc&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
pc + lobits]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"short jump forward"</i></dt>

<dl>
<dt>
self pop&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[]&nbsp; pc&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
pc + lobits - 8];&nbsp;&nbsp;&nbsp;&nbsp; <i>"short branch if false and
pop"</i></dt>
</dl>

<dt>
=10&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[lobits &lt; 8&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[pc&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
lobits - 3 * 256 + self nextbyte + pc]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>"long
jump forward and back"</i></dt>

<dl>
<dt>
self pop&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[pc&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
pc + 1];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"skip extension byte on true"</i></dt>

<dt>
pc&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
lobits - 11 * 256 + self nextbyte + pc];&nbsp;&nbsp;&nbsp;&nbsp; <i>"long
bfp"</i></dt>
</dl>

<dt>
=11&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[lobits =0&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[self pop];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"pop stack"</i></dt>

<dl>
<dl>
<dt>
=1&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[self store: self top into: self nextbyte];&nbsp;&nbsp;&nbsp;&nbsp; <i>"store"</i></dt>

<dt>
=2&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[self store: self pop into: self nextbyte];&nbsp;&nbsp;&nbsp;&nbsp; <i>"store
and pop"</i></dt>

<dt>
=3&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[sender push: self top.&nbsp;<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>sender]]&nbsp;&nbsp;&nbsp;
<i>"return value to sender"</i></dt>
</dl>
</dl>
</dl>

<dt>
]</dt>
</dl>
<b>store: val into: field | lobits</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>
"same encoding as above"</i>
<dl>[lobits&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
byte | 16.
<br>field/16=1&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[receiver instfield: lobits&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
val];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>"store
into instance"</i>
<dl>=2&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[tempframe<img SRC="subscript-bullet.gif" height=9 width=8 align=ABSCENTER>lobits&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
val];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"store into temps (and args)"</i>
<br>=3&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[user notify: 'invalid store'];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"can't store into literals"</i>
<br>=4&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[(method literals: lobits) value&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
val];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>"store indirectly through
literals"</i>
<br>=5&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[self instfield: lobits&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
val]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"store into this Context"</i></dl>
]</dl>
<b>send: message | class meth callee t i</b>&nbsp;&nbsp;&nbsp;&nbsp; <i>"send
a message"</i>
<dl>[class&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
self top class.
<br>until<img SRC="open-colon.gif" height=16 width=8 align=ABSCENTER> (meth&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
class lookup: message) do<img SRC="open-colon.gif" height=16 width=8 align=ABSCENTER>&nbsp;&nbsp;&nbsp;&nbsp;
<i>"look up method"</i>
<dl>[class&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
class superclass.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"follow the superclass chain if necessary"</i>
<br>class = nil&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[user notify: 'Unrecognized message: ' + message]]</dl>
[meth primitive&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"if flagged as primitive, then do it"</i>
<dl>[self doprimitive: meth&nbsp;<img SRC="implication-arrow.gif" height=13 width=14 align=ABSCENTER>
[<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>self]]]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"if it fails, proceed with send"</i></dl>
callee&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
Context new&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"create new Context, and fill its fields"</i>
<dl>sender: self method: meth pc: meth startpc
<br>tempframe: (t<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
Vector new: meth tframesize) stackptr: meth startstack
<br>mclass: class receiver: self pop.</dl>
for<img SRC="open-colon.gif" height=16 width=8 align=ABSCENTER> (i to:
meth nargs) do<img SRC="open-colon.gif" height=16 width=8 align=ABSCENTER>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"pass arguments"</i>
<dl>[t<img SRC="subscript-bullet.gif" height=9 width=8 align=ABSCENTER>i&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
self pop]</dl>
<img SRC="return-arrow.gif" height=14 width=11 align=TEXTTOP>callee]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"return new Context, so it becomes current"</i></dl>
<b>nextbyte</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"step pc an return next code syllable"</i>
<dl>[<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>method<img SRC="subscript-bullet.gif" height=9 width=8 align=ABSCENTER>(pc&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
pc + 1)]</dl>
&nbsp;
<br><b><font size=+1>Stack-related Messages</font></b>
<br><b>push: val</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>"push
value onto top of stack"</i>
<dl>[tempframe<img SRC="subscript-bullet.gif" height=9 width=8 align=ABSCENTER>(stackptr&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
stackptr + 1)&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
val]</dl>
<b>top</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<i>"return value on top of stack"</i>
<dl>[<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>tempframe<img SRC="subscript-bullet.gif" height=9 width=8 align=ABSCENTER>stackptr]</dl>
<b>pop | t</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>"pop
value off stack and return it"</i>
<dl>[t&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
tempframe<img SRC="subscript-bullet.gif" height=9 width=8 align=ABSCENTER>stackptr.
<br>stackptr&nbsp;<img SRC="assignment-arrow.gif" height=12 width=13 align=ABSCENTER>
stackptr - 1.&nbsp;<img SRC="return-arrow.gif" height=14 width=11 align=ABSCENTER>t]</dl>

<hr ALIGN=LEFT SIZE=1 WIDTH="100%">
<center><font color="#666666"><font size=-1>This paper was converted to
HTML (with some recreated graphics) by Dwight Hughes.</font></font></center>
</dl>

</body>

<SCRIPT language="Javascript">
<!--

// FILE ARCHIVED ON 20041207055536 AND RETRIEVED FROM THE
// INTERNET ARCHIVE ON 20090615084757.
// JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.
// ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
// SECTION 108(a)(3)).

   var sWayBackCGI = "http://web.archive.org/web/20041207055536/";

   function xResolveUrl(url) {
      var image = new Image();
      image.src = url;
      return image.src;
   }
   function xLateUrl(aCollection, sProp) {
      var i = 0;
      for(i = 0; i < aCollection.length; i++) {
         var url = aCollection[i][sProp];         if (typeof(url) == "string") { 
          if (url.indexOf("mailto:") == -1 &&
             url.indexOf("javascript:") == -1
             && url.length > 0) {
            if(url.indexOf("http") != 0) {
                url = xResolveUrl(url);
            }
            url = url.replace('.wstub.archive.org','');
            aCollection[i][sProp] = sWayBackCGI + url;
         }
         }
      }
   }

   xLateUrl(document.getElementsByTagName("IMG"),"src");
   xLateUrl(document.getElementsByTagName("A"),"href");
   xLateUrl(document.getElementsByTagName("AREA"),"href");
   xLateUrl(document.getElementsByTagName("OBJECT"),"codebase");
   xLateUrl(document.getElementsByTagName("OBJECT"),"data");
   xLateUrl(document.getElementsByTagName("APPLET"),"codebase");
   xLateUrl(document.getElementsByTagName("APPLET"),"archive");
   xLateUrl(document.getElementsByTagName("EMBED"),"src");
   xLateUrl(document.getElementsByTagName("BODY"),"background");
   xLateUrl(document.getElementsByTagName("TD"),"background");
   xLateUrl(document.getElementsByTagName("INPUT"),"src");
   var forms = document.getElementsByTagName("FORM");
   if (forms) {
       var j = 0;
       for (j = 0; j < forms.length; j++) {
              f = forms[j];
              if (typeof(f.action)  == "string") {
                 if(typeof(f.method)  == "string") {
                     if(typeof(f.method) != "post") {
                        f.action = sWayBackCGI + f.action;
                     }
                  }
              }
        }
    }


//-->
</SCRIPT>

</html>
